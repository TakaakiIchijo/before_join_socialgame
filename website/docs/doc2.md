---
id: doc2
title: 1章:サーバサイドと仲良くなろう
sidebar_label: 1章:サーバサイドと仲良くなろう
---

## サーバサイドって何をしてるの
クライアントサイド、あるいは通信を含まないゲームを作っている人からすると、サーバサイドの人は「何か凄い事をやってる人！」という印象になりがちです。
**もちろん凄い事はやっているのですが** 一体どんなことを知っておくとサーバサイドの人、あるいはサーバと話が出来るようになるでしょうか。

正確な知識を求める場合は基本情報を勉強したり、ネットワーク通信の技術書を読むのが良いですが、この章は最低限、クライアント側が覚えておくと嬉しい事に絞って書いていきます。

## HTTP通信って何
**一言で言うとどんなもの？**

サーバに対して何らかの情報を送って、サーバから何らかの情報を受け取る、という時の標準プロトコルです。


例えばWebブラウザは「僕はGoogle Chrome です。Yahooから検索してこのサイトに飛んできました」という情報を Github.com に送って、Githubのサーバはあなたにサイトの中身のhtmlを返しています。

クライアントのC# + Unityに対してサーバサイドはPHPやGoやRubyやPerlなど、様々な別の言語で書かれています。これら別の言語で書かれたサーバと通信できるように決めた約束事の一つがHTTP通信(HTTP1.0)だと思っておくと良いです。（注:正確には違います）

この規格があるおかげで、サーバとクライアントは別の言語で書いても大丈夫です。

Unityの場合、 HTTP通信をするときに C#(.NET)のHttpClientクラスを使うことも可能ですが、大体の場合UnityWebRequestを使うことが多いです。メモリ的にも、UnityAPIとの親和性的にもUnityWebRequestがおすすめです。
(UnityWebRequestをベースにしたhttpクラスの実装例: https://github.com/sassembla/Autoya/blob/master/Assets/Autoya/Connections/HTTP.cs  )


### http通信の概要例
- お知らせ一覧(例: https://information.com/api/information )を取得する場合

ここで使う用語

| 用語 | 意味 |
----|---- 
| 送信 | 電話の発信、連絡したい先へお問い合わせをすること |
| 受信 | 送信した相手から、返事が返ってくること |

1. unity側でhttp通信を送信する
    1. 番号付きリスト1-1
    1. 番号付きリスト1-2
1. お問い合わせ窓口であるサーバから受信した内容を解析する
1. ゲームの画面に反映する(Loadingが終わってリストが並ぶイメージ

受信したデータの例(うわ、謎の書式だ！と思ってビックリした人、大丈夫です。下にあるJson のところで説明しますので！)


```json
{
     "list": [
        {
          "id":1,
          "title": "夏祭りイベント開始",
          "description": "運営です。 夏祭りイベントを開始いたしました。",
        },
        {
          "id":1,
          "title": "花嫁イベントのお詫び石送付のお知らせ",
          "description": "詫び文章がずっと続く",
        },
    ]
}
```


Unityの画面上の反映例はこんな風になったりします。

| お知らせカテゴリ | タイトル |
----|---- 
| お知らせ | 夏祭りイベント開始 |
| お知らせ | 花嫁イベントのお詫び石送付のお知らせ |



**これの理解や実装が不完全だと何が起きるの？**

サーバエンジニアと話が通じなくなります。

**詳しく知りたい人は、この辺の単語でググってほしい**

- HTTP1.0
- UnityWebRequest

### ヘッダ、ボディ、request、response
HTTP通信は様々な要素があって大変ですが、Unityでサーバと通信するときは **GETとPOSTの2種を覚えておけばほとんどの場合足ります。** (PUTとDELETEはUnityバージョンによって実装が怪しかったことがあった気がします)  

会話例「このAPIってGETになってるけど、クライアントから現在の所持コイン数を渡してあげたいからPOSTにした方が良くないですか？」
### 通信エラーのリトライ処理をしよう

### Jsonって何
GETメソッドやPOSTメソッドなどを使ってサーバと通信するわけですが、それだけでは情報が足りないことが多々あります。(Google検索したときのURLみたいにする手もあるんですが、人間に優しくないので...)  

そんな時は、 **リクエスト、レスポンスのボディに情報を追加** してやり取りを行います。  
その情報の形式としてメジャーなのがJsonになります。  

Unityの組み込みクラスで言うと、 JsonUtilityというクラスが、このJson形式を取り扱うクラスです。  

Jsonは平たく言うと「クラスの変数一覧を特定の書式に変形して作られた文字列string」です。
特定の書式、というルールがあるので

C#のHogeクラス→Hogeクラスの変数をまとめたJson文字列(Jsonのシリアライズ、と言います)  
Hogeクラスの変数をまとめたJson文字列→C#のHogeクラス(Jsonのデシリアライズ、と言います)  

//ここにC#とgoのソースコード例

と言う相互変換が出来ます。

それだけではなく
Hogeクラスの変数をまとめたJson文字列→PHP（あるいはRuby,Goなどサーバサイド)で定義したHogeクラス 

への変換も特定の書式、というルールがあるので実行可能です。すごい！

つまり、以下のように相互変換が出来ます。  
**C#上のHogeクラス⇔Hogeクラスの変数をまとめたJson文字列⇔PHP上で定義したHogeクラス**  

最初にこの仕組みを見たときに僕は感動しました。

なおJsonのデータ構造がサーバとクライアントで違う場合、受け取った側がエラーを吐くので、データ構造のすり合わせはきちんとしましょう。(ユーザーIDのリストが欲しいのに、ユーザーIDが10個個別に送られて来てパース失敗!!みたいな話です)

HTTP通信において **Jsonとは、通信するとき必要に応じて追加する情報の形式で、形にだけ気を付けて、後はUnityのJsonUtilityにお任せする** という認識でOKです。

tips:プロジェクトによって、Jsonを取り扱うクラスがJsonUtilityじゃなくて独自だったり、utf8Jsonなど外部ライブラリの事もあります。あるいはメッチャ最新のJsonみたいなgRPCというやつを使ってる可能性もあります。参加したプロジェクトはJsonライブラリに何を使っているか確認して、なるべくそのライブラリを使いましょう！


### 通信が永続的か永続的じゃないか
いきなり永続的、と言われてもびっくりしてしまいますよね。
ネットワーク通信は、便宜上永続的なものと、永続的じゃないものがあります。  
永続的、というのは「送ったデータをサーバ側で受け取ったあと、サーバ側で常に保持する必要がある通信」だと思ってください。

例えば野球で考えると、ピッチャーが何球目にカーブを投げて、バッターはバットを1.67秒後に振り始めて1.92秒時点でバットに当たって二遊間を抜けて…
のような細かい情報は、全部サーバに保存していたらログが大変なことになってしまいます。


なので「巨人対阪神は6/20日の試合で4:1で決着」みたいな試合結果だけは永続的に保存しておこう。みたいな感じです。

リズムゲームだったら「この曲を難易度HARDで遊ぶ」「結果のスコアは4780点」みたいな通信は永続的です。

リアルタイム対戦系のゲームであれば、対戦中の様々な情報は大体が非永続的なデータで、試合結果だけが永続的、となります。
非永続的なデータはUNETだったりPHOTONだったりMONOBITだったり自前のリアルタイムサーバで処理して、永続的なデータだけはHTTP1.0のPOSTやGETで通信します。

リアルタイム対戦系のゲームではない場合は、ほとんど全てのサーバとの通信は永続的になります。
リアルタイム対戦系のゲームの場合は、　**この通信処理は永続的にすべきかどうか** 、を考えなければいけません。

tips:開発チームに参加したら **「このゲームってリアルタイム通信はありますか？」** と聞いてみましょう。無いようであれば、あなたが考えるべきことは、永続的な通信だけになります！


### 非永続のリアルタイム通信
上で説明したようにHTTP1.0の通信はヘッダ情報などの様々な追加データが載っている為、FPSのキャラ移動など秒間10回以上更新されるリアルタイム情報に使うにはオーバーヘッドが大きすぎます。
なので、FPSゲームなどではリアルタイム通信を永続的(HTTP1.0)ではない普通のUDPやTCPベースで通信します。後述するPhotonなどがこの方式です。

#### Photonか自社製か
#### マッチメイキング
### 暗号化通信(SSL通信)
ところで、大体のソーシャルゲームはJsonという書式の文字列をUnityクライアント側とサーバの間でHTTP通信を使ってやりとりします。

ということは、パケットキャプチャで見たら文字列はダダ漏れでは？という疑問がわいてくる方も居るかと思います。

はい、そのままではダダ漏れです。具体的に言うと、船を擬人化したソーシャルゲームがリリース当初はダダ漏れでした。

Jsonの文字列を解析すると「サーバに何のデータを渡しているか、サーバからどんなデータを受け取っているか」が分かるので、解析を試みたり、自動化ソフトを作られたりします。
あまり嬉しくないですね。

そのため、現在においてはソーシャルゲームの通信暗号化をするのが一般的です。　  
クライアント側で大まかに「どのくらいセキュリティ的に気を遣ってるのかな」をなんとなく把握するための指標を以下に書きます。

レベル1:ダダ漏れ  
レベル2:SSL通信でサーバとクライアントがやりとりする（サーバのurlがhttp:// ではなく https:// になってたらレベル2です）  
レベル3:レベル2に加えて、request bodyやresponse bodyにAESなどの暗号化したJsonを渡す

というレベル順に強固になります。
レベル2も証明書偽造したWireSharkでは覗かれてしまうので、それでも大丈夫であればレベル2,セキュリティを重視するならレベル3、という選択になるかと思います。

tips:もしチームに入って「APIサーバのURLはここ　http:// hogehoge.com 」と教えて貰ったら「本番はhttpsになりますよね？」とサーバエンジニアの人に確認しておきましょう。万が一、本番もhttpのまま進みそうだったら、かなりヤバい予感がします。

## 認証って何
**一言で言うとどんなもの？**

ソーシャルゲームはセーブデータという概念がなく、大体サーバ上でセーブされています。
このセーブデータがAさんのもの、という保証をするために、認証というのが必要になります。

//ここにもう少し詳しい説明
歴史的経緯として、端末固有の（アプリ再インストールでも消えない）固有の長い文字列(UUID)というハードウェアに紐づくデータを、ユーザ認証に使えた時代がありました。
しかし昨今のプライバシー保護の観点から、AppStore,GooglePlayStoreともに、UUIDを取得するアプリは審査時に却下されます。

なので、Unityで使う場合は
```cs
SystemInfo.deviceUniqueIdentifier
```
を端末識別に使っている人が多いと思います。

**これの理解や実装が不完全だと何が起きるの？**

AさんのアカウントにBさんがログインできて、ヤバい事になります。

あるいは、Aさんが昨日遊んだゲームを今日再開したら、また初めからになってしまいます。

**詳しく知りたい人は、この辺の単語でググってほしい**

- 匿名ログイン
- UUID

### 認証方式CookieとJWT
上に書いたように、サーバ側でユーザを特定しておかないと、データの不整合が出てしまいます。  
でも、毎回メールアドレスとパスワードを使ってログインさせると、インターネットのセキュリティ的に嬉しくありません。（そんなに頻繁に変更しないセキュリティ情報を、頻繁にインターネット経由で送らない、というのはネットワークセキュリティの原則です）

なので、メールアドレスとパスワードの代わりにCookieとJWTという仕組みを使うことがソーシャルゲームでは多いです。以下で説明します。

#### Cookieって何
Cookie（クッキー）とは HTTP通信の時にヘッダに付けて送信される短いテキストデータです。
CookieはWebブラウザでもっとも簡易にセッションを識別する方法として用いられます。
セッションとは、Webサーバが接続クライアントを忘れないように付けておく仮の名前です。

まず、Webブラウザが最初にアクセスしてきたときにWebサーバーが「じゃあ、君は次から”7月7日のUnity太郎”と名乗りなさい」とレスポンスヘッダで伝えます。

Webブラウザが次のアクセスの時に、その通りに名乗れば、Webサーバは覚えていてくれて、認証したユーザー情報やショッピングカートなどの状態を引き継ぐことができます。

このときにもしWebブラウザが名乗らなければ、前回の情報はなかったこととなり、また新しい名前が付けられます。

ここで覚えておいてほしいのは、Cookieはただの個体識別情報で、認証情報が記憶されているわけではない、ということです。
認証情報を持っているのは、あくまでWebサーバー側です。

**詳しく知りたい人は、この辺の単語でググってほしい**

- Cookie
- Cookie セキュア

#### JWTって何
JWTは JSON Web Token の略称で、「ジョット」と発音されます。
改ざん検知が出来る文字データの形式です。

JWT自体は、文字列の書式で、Base64エンコードされたヘッダ、ペイロード、署名を”.”（ピリオド）で繋げたものです。
JWT自体は暗号化されているわけではないので、受け取れば誰でも読むことができます。

署名は、ヘッダで決められた計算方法で、ヘッダとペイロードを元に計算される文字列で、ペイロードが改ざんされていないか検知するのに用います。
一度JWTを発行した後にペイロードだけ変えてしまうと、署名が合わなくなり、改ざんが行われたことがバレます。

**詳しく知りたい人は、この辺の単語でググってほしい**

- JWS
- JWT
- RFC7519

#### JWTを認証に使う
JWTだけだとただの文字列なので、これをどう使えば認証として使えるか考えていきましょう。
サーバーがJWTのペイロードに、発行時のIDと有効期限を書き込んで、クライアント側に定期的に更新させます。
一度発行したJWTは有効期限が切れるまでサーバー側で有効とされます。
例えばGoogleのサービスの一つ、FirebaseではJWTの有効期限は1時間とされています。

また、モバイルアプリとブラウザの連携など、cookieを直接渡せない時でも、毎回のやりとりにJWTを付与すれば、認証情報の引き回しが可能となります。

ただ、自前でこの仕組みを実装するとなると、かなりの労力を要するので、アプリケーション開発者であれば、既にあるライブラリを便利に使うほうが安全です。
(例: https://github.com/monry/JWT-for-Unity )

参加したプロジェクトで「アクセストークン」「リフレッシュトークン」という言葉が聞こえてきたら、JWTを使っていると思っておきましょう。

**詳しく知りたい人は、この辺の単語でググってほしい**
- リフレッシュトークン、リフレッシュトークン
- RFC7523
- JWE
- ステートレスJWTとステートフルJWT
- Firebase認証

#### まとめ

ブラウザの機能が内包されていて、外部との連携を行わない場合、Cookieを用いるのが楽で確実です。
Cookieでは乗り越えられない制約を乗り越える時に、JWTなどOAuth2の仕組みを使うと良いでしょう。

### 匿名ログイン
ゲームを開始したユーザはメールアドレスとかパスワードをわざわざ登録したくないです。（アカウント登録を必須にすると初期離脱率がすごいことになります)  
一方で、開発者としてはユーザのアカウント情報（というより、同一端末かどうか)をセーブデータ保持の点からも確認させて貰いたい。  

という二律背反が有ります。

これを解決する仕組みが匿名ログインです。いろいろなパターンがありますが、以下に処理内容の一例を挙げます。

SugoiGameという凄いゲームがあって、 SugoiGameStudio.com で運営しているとします。

1. ユーザAさんはゲームを起動した初回起動時に `SystemInfo.deviceUniqueIdentifier` を取得してAPIサーバのアカウント登録APIにPOSTします。(request bodyに入れてPOSTします)
2. APIサーバはAさん用に a_sanSenyou_sugokunagai_mailaddress@sugoigamestudio.com という仮メールアドレスと、 sugokumuzukasiipasswordde_nagasa128moji みたいな仮パスワードを生成します。（実際は乱数を混ぜますよ！)
3. APIサーバは2.で生成した仮メールアドレスと仮パスワードをアカウント登録APIのresponse bodyに含めてresponseを返します。
4. Aさんは3.で仮メールアドレスと仮パスワードをAPIサーバから受け取りました。Aさんの端末内に **暗号化した**　仮メールアドレスと仮パスワードを保持します。 
5. 以降のゲーム起動時は、4.の仮メールアドレスと仮パスワードを元にAPIサーバのログインAPIにログインをすることが出来ます。
6. とは言え、基本的にはこの仮メールアドレスと仮パスワードを使ったログインは毎回ではなく、大体はクッキーあるいはJWTでのログインをします。あくまでこれは保険ですね。

すごい仕組み！便利！！

しかし、このログイン方式では**プレイヤーの同一性を保証できないので機種変更時の引継ぎに対応できません。**  
機種変更時の引継ぎ対応にはメールアドレスとパスワードを登録してもらう必要があります。そのため、ゲーム内のアカウント情報のところからTwitter連携やメールアドレス登録などが出来るようになっています。  
(お手持ちのゲームを見てみてください。大体そうなっていませんか？)  
 
### 認証を含むHTTP通信

### ソーシャルログインをしよう
ユーザがゲームを遊ぶ時の障壁を出来るだけ下げて、インストールして遊んでもらう人を増やす。というのがソーシャルゲームの大前提になります。
そのためには、ゲームの為だけに専用のメールアドレスとパスワードを登録してもらう、と言うのは相性が悪いです。

「とりあえずゲームを始めてもらう」ということであれば、上にあげた匿名ログインの仕組みによって実現できますが、そのままでは機種変更や（うっかりすると）再インストールなどの引継ぎが出来ないという問題があります。

そのため、メールアドレスとパスワードではなく、多くのユーザが既に使っているサービスのアカウントを使ってゲームにログイン/登録できるようにする、というアイデアが生まれました。
これがソーシャルログインです。

現在において、日本国内で配信するゲームでよく検討されるのは
- Twitterログイン
- LINEログイン
- facebookログイン
- SignInWithApple
- GooglePlayServices

あたりです。クライアントエンジニアは実装の詳細を知る必要はありませんが、どういった事に気を付けておくと良いかを以下に書きます。

#### mBaasを使う
#### 自社基盤を作るか使う
##### SignInWithApple
##### GooglePlayServices
##### Twitter

**詳しく知りたい人は、この辺の単語でググってほしい**

- OAuth2

## アプリバージョンアップをしよう
**一言で言うとどんなもの？**

サーバに対してクライアントは自分のアプリバージョン情報とOS情報を送って、APIサーバから「このアプリは最新か」の結果を受け取ります。

最新ではない（あるいは、最低バージョン以下）だった場合、「アプリをバージョンアップしてください」とダイアログを出してストアのURLに誘導します。

ソーシャルゲームでよく遭遇するアレです。大体の開発現場では、Application.version ではなく独自にAndroidとiOSで別のバージョンを内部で持っている気がします。

**これの理解や実装が不完全だと何が起きるの？**

- ゲーム中にスリープして、一カ月後に再開したユーザが古いクライアントアプリのままAPIサーバにアクセス。APIの仕様が変わっている為謎のエラーをサーバが連発！
- リリースしたバージョンに致命的なチート可能バグを発見！Androidだけ先に審査を通ったけど強制アップデート機構が動かなかった！！死ぬ！

などがあります。

**詳しく知りたい人は、この辺の単語でググってほしい**

- 強制アップデート
- https://sassembla.github.io/Autoya/docs/en/update_app_version0.html

### 強制アップデートのチェックするタイミング
大体の場合は専用の [GET] /ios/version を使うより、**httpのresponse headerで判定** することが多い気がします。
専用APIで判定する場合、スリープ復帰の関係でうっかりすり抜けることがある為です。（前項参照）

### リソースバージョンとアプリバージョン
ソーシャルゲームの場合、先にシナリオやアイテムのデータだけを更新する。イベントのためにリソースデータだけ更新する。

という事が起きます。なので、UnityのApplication.versionではなく独自定義した
- AppVersion
- ResourceVersion(AssetBundleVersion)
- MasterDataVersion

を持っていることが多いです。

## In-App-Purchase（アプリ内課金,IAP）
**一言で言うとどんなもの？**

楽しいアプリ内課金です。基本プレイ無料のソーシャルゲームにおいて、きわめて大事なマネタイズポイントです。

大体はUnity IAPのpackageをベースに自前で拡張します。

歴史的な、というか偉大なるプラットフォームパワーによって30%の手数料を取られるのがつらいですが、しかし課金迂回はあまりにリスキーです。
あきらめてプラットフォーム推奨の課金処理に従いましょう。

**これの理解や実装が不完全だと何が起きるの？**

- 100魔法石を買おうとした人が「このアイテムは購入できません」と出て死ぬ
- 1万円分の魔法石を購入失敗したユーザがアプリの再インストールをした結果、魔法石が消滅。会計処理も死ぬしユーザは激おこ
- 「僕は500万円分の魔法石を買ったのに付与されてない、補填してください」というユーザさんが出て死ぬ

**詳しく知りたい人は、この辺の単語でググってほしい**

- レシート検証
- transaction queue

### レシート検証
### サブスクリプションの注意
